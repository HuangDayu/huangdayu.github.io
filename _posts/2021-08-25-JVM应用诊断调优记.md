---
title: JVM应用诊断调优记
date: 2021-08-25
categories: 
- 研讨技术
layout: post
comments: true
published: true
permalink: /blog/52
---


## 前言

---

&emsp;&emsp;成为Javaer已经几年，但并没有真正的触碰到Java的核心，一直执着于高层API的使用。近来因项目需要，做性能测试和诊断调优，以此为记。

<blockquote class="blockquote-center">
<p style="font-size: 30px;text-align: center;">工欲善其事，必先利其器。</p>
</blockquote>
<!-- more -->

## JVM应用常见问题

---

1. Full GC出现的频繁
2. 堆栈异常
3. CPU load 负载过高
4. 内存泄露或使用过高
5. 程序死锁或锁的性能问题
6. Out Of Memory
7. 相应时间长，吞吐量低
8. TPS不平稳
9. JVM应用假死或僵尸进程

## JVM应用问题常见原因

---

1. 网络带宽
2. 数据库连接配置（连接池等）
3. 数据库索引设计，大表插入查询，排序字段，SQL性能等
4. 各种池的配置，TCP/HTTP连接池，线程池，实例池，内存池等
5. 线程池核心数，线程池任务队列大小不合理，消费生产不成比例
6. 列表，集合，队列，线程池大小太大，一直占用较大内存且不回收不消费不释放
7. 通信连接机制（阻塞式，响应式，异步式）
8. 垃圾回收机制（新生代的Eden和Survivor区频繁的进行Minor GC，老年代的full GC也回收较频繁会占用一定的资源）
9. 程序代码效率与性能
10. 业务逻辑复杂程度
11. 异步任务消费处理效率
12. 设计模式运用不合理
13. 定时任务时间间隔与性能问题
14. 硬件资源，例如磁盘读写速度或磁盘容量
15. 系统架构，例如复杂且冗长的程序调用链路
16. 框架性能问题，例如大量的Logger输出就会受到Logger框架性能的限制
17. 应用配置问题
18. 测试工具，测试环境，测试用例，测试脚本，测试配置等问题

## JVM应用诊断方向

---

1. 运行日志分析
2. GC日志分析
3. 线程快照分析
4. 堆内存转储分析
5. 堆栈日志分析
6. 耗时统计分析
7. 网络连接数量与状态
8. 实时JVM状态分析
9. 实时系统性能指标监控
10. 实时JVM应用性能指标监控
11. 各种连接池配置
12. 数据库或SQL性能分析
13. 对使用的框架，工具进行性能测试
14. Code Review

## JVM应用调优方向

---

1. 合理设置各种连接池（HTTP，TCP，数据库）
2. 合理设置各种线程池（业务线程池，框架线程池，拒绝策略）
3. JVM调优，如适当增加内存
4. 根据业务背景选择垃圾回收器
5. 优化代码，控制内存使用
6. 增加机器，分散节点压力
7. 使用中间件提高程序效率，比如缓存、消息队列等
8. 优化业务逻辑，减少IO与网络通信
9. 优化架构，减少跨边界调用
10. 优化外部框架配置或选型跟符合业务的框架（`tomcat`，`undertow`，`jetty`）

## Linux命令行工具 

---

|     命令     |                    示例                    |                             说明                             |
| :----------: | :----------------------------------------: | :----------------------------------------------------------: |
|    `tail`    |             `tail -f fileName`             | tail用于显示文件尾部的内容，默认在屏幕上显示指定文件的末尾10行。 |
|    `find`    |          `find ./ -name fileName`          |     find命令可以根据给定的路径和表达式查找的文件或目录。     |
|   `fgrep`    |           `fgrep content *.java`           |                     为文件搜索文字字符串                     |
|    `awk`     |        `awk '{ print $2,$3 }' file`        |                 文本和数据进行处理的编程语言                 |
|    `top`     |                  `top -H`                  |                       实时显示进程动态                       |
|     `ss`     | `ss -anp | grep 8081 | grep ESTAB | wc -l` |                      显示活动套接字信息                      |
|    `sar`     |                  `sar -u`                  |                       系统运行状态统计                       |
|   `pstack`   |        `pstack 31440 >> pstack.log`        |                     显示每个进程的栈跟踪                     |
|    `perf`    |           `perf trace -p 12080`            |          Perf是Linux kernel自带的系统性能优化工具。          |
| `interrupts` |           `cat /proc/interrupts`           |                       观察cpu的si指标                        |
|   `dmesg `   |               `dmesg -l err`               |                         查看启动日志                         |
|    `gdb`     |             `gdb -pid=12080`              |                    Linux GUN debugger工具                    |

## Java 命令行工具

---

|   命令   |                           常用示例                           |                             说明                             |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  `jps`   |                         `jps -l -v`                          | 查看正在运行的Java进程，[官方文档](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jps.html) |
| `jstat`  |                  `jstat -gc -t pid 1000 10`                  | 查看JVM统计信息，[官方文档](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html) |
| `jinfo`  |                         `jinfo pid`                          | 实时查看和修改JVM配置参数，[官方文档](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html) |
|  `jmap`  |         `jmap -dump:live,format=b,file=heap.bin pid`         | 导出内存映像文件，用MAT做分析，[官方文档](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html) |
|  `jhat`  |                 `jhat -stack true heap.bin`                  | JDK自带堆分析工具，[官方文档](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jhat.html) |
| `jstack` |         ```jstack -l 12080 | grep WAITING | wc -l```         | 打印JVM中线程快照，[官方文档](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html) |
|  `jcmd`  | ```jcmd pid JFR.start name=12080 settings=profile delay=3s duration=5m filename=./12080.jfr compress=true``` | 虚拟机 (JVM) 诊断，用JMC做分析，[官方文档](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jcmd.html) |
| `jstatd` | ```jrmiregistry 2020 & jstatd -J-Djava.security.policy=all.policy -p 2020``` | 远程主机信息收集，[官方文档](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstatd.html) |

## Java GUI工具

---

|       工具       |                             说明                             |
| :--------------: | :----------------------------------------------------------: |
|    `JConsole`    | JDK自带的可视化监控工具。查看Java应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等，[官方文档](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jconsole.html) |
|   `Visual VM`    | `Visual VM`是一个工具，它提供了一个可视界面，用于查看Java虚拟机上运行的基于Java技术的应用程序的详细信息。[官方文档](https://visualvm.github.io/index.html) |
|      `JMC`       | `Java Mission Control`，内置`Java Flight Recorder`。能够以极低的性能开销收集Java虚拟机的性能数据。[官方文档](https://www.oracle.com/java/technologies/jdk-mission-control.html) |
|      `MAT`       | `Memory Analyzer Tool` 是基于Eclipse的内存分析工具，是一个快速、功能丰富的Java heap分析工具。[官方文档](https://www.eclipse.org/mat/downloads.php) |
|   `JProfiler`    | `JProfiler` 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具。[官方文档](https://www.ej-technologies.com/products/jprofiler/overview.html) |
|     `Arthas`     | 开源Java应用诊断利器，可以嵌入应用或者在应用坏境中分析诊断应用。[官方文档](https://arthas.aliyun.com/doc/quick-start.html) |
|     `BTrace`     | 适用于 Java 平台的安全、动态跟踪工具。[官方文档](https://github.com/btraceio/btrace) |
| `Greys-Anatomy`  | Java诊断工具，[官方文档](https://github.com/oldmanpushcart/greys-anatomy) |
|    `Byteman`     | `Byteman` 是一个可以轻松跟踪、监控和测试 Java 应用程序和 JDK 运行时代码行为的工具，[官方文档](https://byteman.jboss.org/) |
|    `YourKit`     | CPU 和内存 Java 分析，[官方文档](https://www.yourkit.com/java/profiler/features/) |
| `Async-Profiler` | 具有 `AsyncGetCallTrace` + `perf_events` 的 Java 采样 CPU 和 HEAP 分析器，[官方文档](https://github.com/jvm-profiling-tools/async-profiler) |
|   `TProfiler`    | `TProfiler`是一个可以在生产环境长期使用的性能分析工具，[官方文档](https://github.com/alibaba/Tprofiler) |
|   GC analysis    | GC analysis 是一个GC日志在线分析平台，[官方文档](https://gceasy.io/) |

## JVM常用命令

---

|                示例                |                             说明                             |
| :--------------------------------: | :----------------------------------------------------------: |
|             `java -jar demo.jar`              |                        执行Jar包                        |
|            `java -help`            | 查看标准参数选项，[官方文档](https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html) |
|             `java -X`              |                        查看-X参数选项                        |
|       `java jar -tvf *.jar`        |                       参看冲突的Class                        |
|  `jinfo -flag [+|-]<name> <pid>`   |                  运行时设置Boolean类型参数                   |
| `jinfo -flag <name>=<value> <pid>` |                 运行时设置非Boolean类型参数                  |

## JVM常用参数选项

---

```shell

# Boolean类型格式
-XX:+<option>  启用option属性
-XX:-<option>  禁用option属性

# 非Boolean类型格式
-XX:<option>=<number>  设置option数值，可以带单位如k/K/m/M/g/G
-XX:<option>=<string>  设置option字符值

# 打印设置的XX选项及值
-XX:+PrintCommandLineFlags 程序运行时JVM默认设置或用户手动设置的XX选项
-XX:+PrintFlagsInitial 打印所有XX选项的默认值
-XX:+PrintFlagsFinal 打印所有XX选项的实际值
-XX:+PrintVMOptions 打印JVM的参数

# 栈
-Xss128k <==> -XX:ThreadStackSize=128k 设置线程栈的大小为128K

# 堆
-Xms2048m <==> -XX:InitialHeapSize=2048m 设置JVM初始堆内存为2048M
-Xmx2048m <==> -XX:MaxHeapSize=2048m 设置JVM最大堆内存为2048M
-Xmn2g <==> -XX:NewSize=2g -XX:MaxNewSize=2g 设置年轻代大小为2G
-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8
-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2
-XX:+UseAdaptiveSizePolicy 设置大小比例自适应，默认开启
-XX:PretenureSizeThreadshold=1024 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效
-XX:MaxTenuringThreshold=15 设置新生代晋升老年代的年龄限制，默认为15
-XX:TargetSurvivorRatio 设置MinorGC结束后Survivor区占用空间的期望比例

# 方法区
-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M
-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m 设置元空间/永久代最大值为256M
-XX:+UseCompressedOops 使用压缩对象
-XX:+UseCompressedClassPointers 使用压缩类指针
-XX:CompressedClassSpaceSize 设置Klass Metaspace的大小，默认1G

# 直接内存
-XX:MaxDirectMemorySize 指定DirectMemory容量，默认等于Java堆最大值

# OutOfMemory相关的选项
-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件，两者互斥
-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件，两者互斥
-XX:HeapDumpPath=<path> 指定heap转储文件的存储路径，默认当前目录
-XX:OnOutOfMemoryError=<path> 指定可行性程序或脚本的路径，当发生OOM时执行脚本

# Serial回收器
-XX:+UseSerialGC  年轻代使用Serial GC， 老年代使用Serial Old GC

# ParNew回收器
-XX:+UseParNewGC  年轻代使用ParNew GC
-XX:ParallelGCThreads  设置年轻代并行收集器的线程数。
    一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。

# CMS回收器
-XX:+UseConcMarkSweepGC  年轻代使用CMS GC。
    开启该参数后会自动将-XX：＋UseParNewGC打开。即：ParNew（Young区）+ CMS（Old区）+ Serial Old的组合
-XX:CMSInitiatingOccupanyFraction  设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，DK6及以上版本默认值为92％。
    如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。
    反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。
    因此通过该选项便可以有效降低Fu1l GC的执行次数。
-XX:+UseCMSInitiatingOccupancyOnly  是否动态可调，使CMS一直按CMSInitiatingOccupancyFraction设定的值启动
-XX:+UseCMSCompactAtFullCollection  用于指定在执行完Full GC后对内存空间进行压缩整理
    以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。
-XX:CMSFullGCsBeforeCompaction  设置在执行多少次Full GC后对内存空间进行压缩整理。
-XX:ParallelCMSThreads  设置CMS的线程数量。
    CMS 默认启动的线程数是(ParallelGCThreads＋3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。
    当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。
-XX:ConcGCThreads  设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的
-XX:+CMSScavengeBeforeRemark  强制hotspot在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度
-XX:+CMSClassUnloadingEnable  如果有的话，启用回收Perm 区（JDK8之前）
-XX:+CMSParallelInitialEnabled  用于开启CMS initial-mark阶段采用多线程的方式进行标记
    用于提高标记速度，在Java8开始已经默认开启
-XX:+CMSParallelRemarkEnabled  用户开启CMS remark阶段采用多线程的方式进行重新标记，默认开启
-XX:+ExplicitGCInvokesConcurrent
-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses
    这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期
-XX:+CMSPrecleaningEnabled  指定CMS是否需要进行Pre cleaning阶段

# G1回收器
-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。
-XX:G1HeapRegionSize 设置每个Region的大小。
    值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。
-XX:MaxGCPauseMillis  设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms
-XX:ParallelGCThread  设置STW时GC线程数的值。最多设置为8
-XX:ConcGCThreads  设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。
-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。
-XX:G1NewSizePercent  新生代占用整个堆内存的最小百分比（默认5％）
-XX:G1MaxNewSizePercent  新生代占用整个堆内存的最大百分比（默认60％）
-XX:G1ReservePercent=10  保留内存区域，防止 to space（Survivor中的to区）溢出

# GC日志相关选项
-XX:+PrintGC <==> -verbose:gc  打印简要日志信息
-XX:+PrintGCDetails            打印详细日志信息
-XX:+PrintGCTimeStamps  打印程序启动到GC发生的时间，搭配-XX:+PrintGCDetails使用
-XX:+PrintGCDateStamps  打印GC发生时的时间戳，搭配-XX:+PrintGCDetails使用
-XX:+PrintHeapAtGC  打印GC前后的堆信息，如下图
-Xloggc:<file> 输出GC导指定路径下的文件中
-XX:+TraceClassLoading  监控类的加载
-XX:+PrintGCApplicationStoppedTime  打印GC时线程的停顿时间
-XX:+PrintGCApplicationConcurrentTime  打印垃圾收集之前应用未中断的执行时间
-XX:+PrintReferenceGC 打印回收了多少种不同引用类型的引用
-XX:+PrintTenuringDistribution  打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布
-XX:+UseGCLogFileRotation 启用GC日志文件的自动转储
-XX:NumberOfGCLogFiles=1  设置GC日志文件的循环数目
-XX:GCLogFileSize=1M  设置GC日志文件的大小

# 支持JFR
-XX:+UnlockCommercialFeatures -XX:+FlightRecorder

# 其他参数
-XX:+DisableExplicitGC  禁用hotspot执行System.gc()，默认禁用
-XX:ReservedCodeCacheSize=<n>[g|m|k]、-XX:InitialCodeCacheSize=<n>[g|m|k]  指定代码缓存的大小
-XX:+UseCodeCacheFlushing  放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况
-XX:+DoEscapeAnalysis  开启逃逸分析
-XX:+UseBiasedLocking  开启偏向锁
-XX:+UseLargePages  开启使用大页面
-XX:+PrintTLAB  打印TLAB的使用情况
-XX:TLABSize  设置TLAB大小
```

## 代码检查工具

---

1. [Maven Enforcer](http://maven.apache.org/enforcer/maven-enforcer-plugin/index.html) 插件提供了控制某些环境约束的目标，例如 Maven 版本、JDK 版本和 OS 系列以及更多内置规则和用户创建的规则。
2. [OSS Index](https://ossindex.sonatype.org/browse/maven?page=0) 是开源组件和扫描工具的免费目录，可帮助开发人员识别漏洞、了解风险并确保其软件安全。
3. [OWASP Maven Dependency Check](https://jeremylong.github.io/DependencyCheck/dependency-check-maven/index.html) 插件支持依赖项安全检查，它从 NIST 托管的国家漏洞数据库 ([NVD](https://nvd.nist.gov/)) 下载和处理安全漏洞，运行`./mvnw verify`将在`target`目录下生成一个依赖项检查报告。
4. [ArchUnit](https://www.archunit.org/) 是一个免费、简单且可扩展的库，用于使用任何普通 Java 单元测试框架检查 Java 代码的体系结构。也就是说，ArchUnit 可以检查包和类、层和切片之间的依赖关系，检查循环依赖关系等等。它通过分析给定的 Java 字节码，将所有类导入 Java 代码结构来实现。您可以在[ ArchUnit 示例](https://github.com/TNG/ArchUnit-Examples)和 [GitHub](https://github.com/TNG/ArchUnit) 上的源中找到当前版本的[示例](https://juejin.cn/post/6844903957635006472#heading-0)。
5. [GitHub Dependabot](https://dependabot.com/) 创建拉取请求以确保依赖项安全且保持最新。
6. [Snyk](https://snyk.io/)的漏洞扫描器可以帮助你找到并修复项目中的安全漏洞和代码质量问题，所有这些都可以在你最喜欢的IDE中进行。在几秒钟内，该插件将提供一个列表，列出所有不同类型的问题，并将其归类，同时提供可操作的修复建议。
7. [Sonarqube](https://www.sonarqube.org/downloads/)为静态代码检查工具，采用`B/S`架构，帮助检查代码缺陷，可以快速的定位代码中潜在的或者明显的错误，改善代码质量，提高开发速度。

## 总结

&emsp;&emsp;虽说工欲善其事，必先利其器，但任何技术或工具都只是实现需求的手段。有其果必有其因，解决问题我们应该从根源上着手，整洁架构，改善设计，规范编码，划定边界，制定标准，坚决执行，防患于未然。

## 参考文献

---

- [Java JDK 工具集](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/)
- [性能测试中TPS上不去的几种原因浅析](https://www.cnblogs.com/imyalost/p/8309468.html)
- [JVM监控及诊断工具-GUI篇](https://www.cnblogs.com/lvxueyang/p/14833555.html)
- [JVM监控及诊断工具-命令行篇](https://www.cnblogs.com/lvxueyang/p/14833528.html)
- [性能监控与调优(概述篇)](https://www.cnblogs.com/lvxueyang/p/14833493.html)
- [JVM运行时参数](https://www.cnblogs.com/lvxueyang/p/14833576.html)
- [分析GC日志](https://www.cnblogs.com/lvxueyang/p/14833582.html)
- [Java问题排查工具箱](https://mp.weixin.qq.com/s/dLp0EfUOLq3gz6Plz9nowg)
- [jstat 和 jstack 无法访问 JVM](https://confluence.atlassian.com/kb/jvm-is-not-reachable-with-jstat-and-jstack-1031281491.html)
- [依赖漏洞检查](https://www.jhipster.tech/cn/dependency-vulnerabities-check/)
- [owasp 十大 Web 应用程序安全风险](https://owasp.org/www-project-top-ten/)

## 更新记录

|    时间    |       说明       |
| :--------: | :--------------: |
| 2021-08-25 |    初稿并发布    |
| 2021-09-09 | 追加代码检查工具 |

